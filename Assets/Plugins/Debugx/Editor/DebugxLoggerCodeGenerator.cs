using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using UnityEditor;
using UnityEngine;

namespace DebugxLog.Editor
{
    /// <summary>
    /// Code generator for Debugx class.
    /// Automatically generates member-specific Log methods based on DebugxProjectSettingsAsset configuration.
    /// 为 Debugx 类自动生成代码。
    /// 根据 DebugxProjectSettingsAsset 配置自动生成成员专用的 Log 方法。
    /// </summary>
    public static class DebugxLoggerCodeGenerator
    {
        private const string DebugxClassPath = "Assets/Plugins/Debugx/Runtime/DebugxLogger.cs";
        
        // Regex to validate C# identifier (method name)
        private static readonly Regex _validIdentifierRegex = new Regex(@"^[a-zA-Z_][a-zA-Z0-9_]*$");

        /// <summary>
        /// Generate Debugx.cs file with member-specific Log methods.
        /// 生成包含成员专用 Log 方法的 Debugx.cs 文件。
        /// </summary>
        public static void GenerateDebugxLoggerClass()
        {
            var settingsAsset = DebugxProjectSettingsAsset.Instance;
            if (settingsAsset == null)
            {
                Debug.LogWarning("[DebugxCodeGenerator] DebugxProjectSettingsAsset not found.");
                return;
            }

            StringBuilder sb = new StringBuilder();
            
            // File header
            sb.AppendLine("// 此文件由 DebugxCodeGenerator 自动生成，请勿手动修改。");
            sb.AppendLine("// Auto-generated by DebugxCodeGenerator. Do not modify manually.");
            sb.AppendLine("// HideInCallstack 特性可以隐藏调用栈中的此方法，方便查看调用者。必须在 Console 窗口中点击设置后勾选 “Strip logging callstack” 后才能生效。");
            sb.AppendLine("// The HideInCallstack attribute can hide this method from the call stack, making it easier to see the caller. \n// It only takes effect after checking \"Strip logging callstack\" in the Console window settings.");
            sb.AppendLine("// 使用 Logger 结尾的类名可以在双击 Console 窗口的日志时在此类为止阻断，方便查看调用 Log 的业务逻辑位置。");
            sb.AppendLine("// Class names ending with Logger can block at this class when double-clicking logs in the Console window, \n// making it easier to see the business logic location that called Log.");
            sb.AppendLine();
            sb.AppendLine("#if !DEBUGX_IN_UPM");
            sb.AppendLine("using System.Diagnostics;");
            sb.AppendLine("using DebugxLog;");
            sb.AppendLine("using UnityEngine;");
            sb.AppendLine();
            sb.AppendLine("public static class DebugxLogger");
            sb.AppendLine("{");

            // Generate methods for default members
            if (settingsAsset.defaultMemberAssets != null)
            {
                foreach (var member in settingsAsset.defaultMemberAssets)
                {
                    GenerateMemberMethods(sb, member);
                }
            }

            // Generate methods for custom members
            if (settingsAsset.customMemberAssets != null)
            {
                foreach (var member in settingsAsset.customMemberAssets)
                {
                    GenerateMemberMethods(sb, member);
                }
            }

            sb.AppendLine("}");
            sb.AppendLine("#endif");
            
            // Write to file
            string absolutePath = Path.Combine(Application.dataPath, "..", DebugxClassPath);
            string directory = Path.GetDirectoryName(absolutePath);
            if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
            {
                Directory.CreateDirectory(directory);
            }

            string newContent = sb.ToString();
            
            // Check if content changed
            if (File.Exists(absolutePath))
            {
                string existingContent = File.ReadAllText(absolutePath);
                if (existingContent == newContent)
                {
                    return; // No changes needed
                }
            }

            File.WriteAllText(absolutePath, newContent, Encoding.UTF8);
            AssetDatabase.Refresh();
            
            Debug.Log("[DebugxCodeGenerator] Debugx.cs generated successfully.");
        }

        /// <summary>
        /// Generate Log, LogWarning, LogError methods for a member.
        /// 为成员生成 Log、LogWarning、LogError 方法。
        /// </summary>
        private static void GenerateMemberMethods(StringBuilder sb, DebugxMemberInfoAsset member)
        {
            if (string.IsNullOrEmpty(member.signature))
                return;

            string methodSuffix = SanitizeMethodName(member.signature);
            if (string.IsNullOrEmpty(methodSuffix))
                return;

            int key = member.key;

            // Log method
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// Log for member [{member.signature}] (Key: {key}).");
            sb.AppendLine($"    /// 成员 [{member.signature}] 的 Log 方法 (Key: {key})。");
            sb.AppendLine($"    /// </summary>");
            sb.AppendLine($"    [Conditional(\"DEBUG_X\"), HideInCallstack]");
            sb.AppendLine($"    public static void Log{methodSuffix}(object message, bool showTime = false, bool showNetTag = false)");
            sb.AppendLine($"    {{");
            sb.AppendLine($"        Debugx.Log({key}, message, showTime, showNetTag);");
            sb.AppendLine($"    }}");
            sb.AppendLine();

            // LogWarning method
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// LogWarning for member [{member.signature}] (Key: {key}).");
            sb.AppendLine($"    /// 成员 [{member.signature}] 的 LogWarning 方法 (Key: {key})。");
            sb.AppendLine($"    /// </summary>");
            sb.AppendLine($"    [Conditional(\"DEBUG_X\"), HideInCallstack]");
            sb.AppendLine($"    public static void LogWarning{methodSuffix}(object message, bool showTime = false, bool showNetTag = false)");
            sb.AppendLine($"    {{");
            sb.AppendLine($"        Debugx.LogWarning({key}, message, showTime, showNetTag);");
            sb.AppendLine($"    }}");
            sb.AppendLine();

            // LogError method
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// LogError for member [{member.signature}] (Key: {key}).");
            sb.AppendLine($"    /// 成员 [{member.signature}] 的 LogError 方法 (Key: {key})。");
            sb.AppendLine($"    /// </summary>");
            sb.AppendLine($"    [Conditional(\"DEBUG_X\"), HideInCallstack]");
            sb.AppendLine($"    public static void LogError{methodSuffix}(object message, bool showTime = false, bool showNetTag = false)");
            sb.AppendLine($"    {{");
            sb.AppendLine($"        Debugx.LogError({key}, message, showTime, showNetTag);");
            sb.AppendLine($"    }}");
            sb.AppendLine();
        }

        /// <summary>
        /// Sanitize signature to be a valid C# method name.
        /// 将签名转换为有效的 C# 方法名。
        /// </summary>
        private static string SanitizeMethodName(string signature)
        {
            if (string.IsNullOrEmpty(signature))
                return null;

            // Remove spaces and invalid characters
            StringBuilder sb = new StringBuilder();
            bool capitalizeNext = false;
            
            foreach (char c in signature)
            {
                if (char.IsLetterOrDigit(c) || c == '_')
                {
                    if (capitalizeNext && char.IsLetter(c))
                    {
                        sb.Append(char.ToUpper(c));
                        capitalizeNext = false;
                    }
                    else
                    {
                        sb.Append(c);
                    }
                }
                else if (c == ' ' || c == '-' || c == '.')
                {
                    // Use PascalCase for spaces/dashes/dots
                    capitalizeNext = true;
                }
            }

            string result = sb.ToString();
            
            // Ensure it doesn't start with a digit
            if (result.Length > 0 && char.IsDigit(result[0]))
            {
                result = "_" + result;
            }

            // Validate the result
            if (string.IsNullOrEmpty(result) || !_validIdentifierRegex.IsMatch(result))
            {
                Debug.LogWarning($"[DebugxCodeGenerator] Cannot generate method for signature '{signature}' - invalid identifier.");
                return null;
            }

            return result;
        }

        /// <summary>
        /// Menu item to manually regenerate Debugx.cs.
        /// 手动重新生成 Debugx.cs 的菜单项。
        /// </summary>
        [MenuItem("Tools/Debugx/Regenerate DebugxLogger Class")]
        public static void RegenerateDebugxClass()
        {
            GenerateDebugxLoggerClass();
        }
    }
}

